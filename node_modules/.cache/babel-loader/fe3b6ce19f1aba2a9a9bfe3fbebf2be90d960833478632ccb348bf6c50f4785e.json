{"ast":null,"code":"var _s = $RefreshSig$();\n//Main\nimport { useRef, useEffect } from 'react';\n\n//Additional Files\nimport { useIsMount } from '../useIsMount';\n\n//*********REFRENCE**************/\n//props.AccessorySelection[] \n//AccessorieID(int), ObjectID(int), TextureChange(bool), UID(int)\n//*********REFRENCE**************/\n\nexport const MaterialChange = (props, apiRef, materials, nodes) => {\n  _s();\n  // console.log(materials)\n  //Function that runs and returns a bool on initial mount\n  const isMount = useIsMount();\n  useEffect(() => {\n    if (isMount) {\n      // console.log('mounting in textureChange')\n    } else {\n      console.log(\"MATCHANGE\");\n      //TODO:Setting this manually is bad and not scalable. This was only done to select the materials within objects that contained multiple materials\n      //In this setup we manually search and store the values of the location of the materials we know will be changed out. \n      const objectsStateID = [4, 1, 29, 1]; //[FCU, Base, Slide, Barrel] [Accessories material setID Manually set. \n\n      if (props.AccessorySelection[2]) {\n        //confirms that it will be a texture change. (props.AccessorySelection[2] returns true or false)\n\n        //Loop through materials and find changable materials by names. Then we switch their position and replace it with the correct material slot placement. \n        for (var i = 0; i < materials.current.length; i++) {\n          if (materials.current[i].name.endsWith(props.AccessorySelection[0])) {\n            if (materials.current[i].name.match(/^\\d/)) {\n              if (materials.current[i].name.startsWith(props.AccessorySelection[1])) {\n                materials.current[i].stateSetID = objectsStateID[props.AccessorySelection[0]];\n                apiRef.current.setMaterial(materials.current[i], function (err) {\n                  // console.log('Material Assigned')\n                });\n              }\n            }\n          }\n\n          //If Reset Configuration is selected.\n          if (props.AccessorySelection[3] === 1000000) {\n            if (materials.current[i].name.startsWith(0)) {\n              // console.log('all default material')\n\n              materials.current[i].stateSetID = objectsStateID[materials.current[i].name.charAt(materials.current[i].name.length - 1)];\n              apiRef.current.setMaterial(materials.current[i], function (err) {\n                // console.log('Material Assigned')\n              });\n            }\n            // console.log('Reset all materials')\n          }\n        }\n      } else {\n        // console.log('Only model will be changed')\n      }\n    }\n  }, [props.AccessorySelection]);\n};\n_s(MaterialChange, \"WpLIN+14gCkECZeu9s1wHPvd3Vg=\", false, function () {\n  return [useIsMount];\n});\n_c = MaterialChange;\nvar _c;\n$RefreshReg$(_c, \"MaterialChange\");","map":{"version":3,"names":["useRef","useEffect","useIsMount","MaterialChange","props","apiRef","materials","nodes","_s","isMount","console","log","objectsStateID","AccessorySelection","i","current","length","name","endsWith","match","startsWith","stateSetID","setMaterial","err","charAt","_c","$RefreshReg$"],"sources":["/Users/nando/Documents/GitHub/Sketchfab_Configurator/src/Componets/3DComponents/MaterialChange.jsx"],"sourcesContent":["//Main\nimport { useRef, useEffect } from 'react';\n\n//Additional Files\nimport { useIsMount } from '../useIsMount';\n\n//*********REFRENCE**************/\n    //props.AccessorySelection[] \n    //AccessorieID(int), ObjectID(int), TextureChange(bool), UID(int)\n//*********REFRENCE**************/\n\nexport const MaterialChange = ( props, apiRef, materials, nodes ) => {\n    // console.log(materials)\n    //Function that runs and returns a bool on initial mount\n    const isMount = useIsMount();\n    useEffect(() => {\n        if(isMount){\n            // console.log('mounting in textureChange')\n        }else{\n            console.log(\"MATCHANGE\")\n            //TODO:Setting this manually is bad and not scalable. This was only done to select the materials within objects that contained multiple materials\n            //In this setup we manually search and store the values of the location of the materials we know will be changed out. \n            const objectsStateID = [4,1,29,1]//[FCU, Base, Slide, Barrel] [Accessories material setID Manually set. \n\n            if(props.AccessorySelection[2]){//confirms that it will be a texture change. (props.AccessorySelection[2] returns true or false)\n\n                //Loop through materials and find changable materials by names. Then we switch their position and replace it with the correct material slot placement. \n                for (var i = 0; i < materials.current.length; i++) {\n                    if(materials.current[i].name.endsWith(props.AccessorySelection[0])){\n                        if( materials.current[i].name.match(/^\\d/) ){ \n                            if(materials.current[i].name.startsWith(props.AccessorySelection[1])){\n                                materials.current[i].stateSetID  = objectsStateID[props.AccessorySelection[0]]\n                                apiRef.current.setMaterial(materials.current[i], function(err) {\n                                    // console.log('Material Assigned')\n                                });\n                            }\n                        }\n                    }\n\n                    //If Reset Configuration is selected.\n                    if(props.AccessorySelection[3] === 1000000){\n                        if(materials.current[i].name.startsWith(0)){\n                            // console.log('all default material')\n                            \n                            materials.current[i].stateSetID  = objectsStateID[materials.current[i].name.charAt(materials.current[i].name.length - 1)]\n                            apiRef.current.setMaterial(materials.current[i], function(err) {\n                                // console.log('Material Assigned')\n                            });\n                        }\n                        // console.log('Reset all materials')\n                    }\n                }\n\n            }else{\n                // console.log('Only model will be changed')\n            }\n        }\n      }, [props.AccessorySelection ]);\n    \n}"],"mappings":";AAAA;AACA,SAASA,MAAM,EAAEC,SAAS,QAAQ,OAAO;;AAEzC;AACA,SAASC,UAAU,QAAQ,eAAe;;AAE1C;AACI;AACA;AACJ;;AAEA,OAAO,MAAMC,cAAc,GAAGA,CAAEC,KAAK,EAAEC,MAAM,EAAEC,SAAS,EAAEC,KAAK,KAAM;EAAAC,EAAA;EACjE;EACA;EACA,MAAMC,OAAO,GAAGP,UAAU,CAAC,CAAC;EAC5BD,SAAS,CAAC,MAAM;IACZ,IAAGQ,OAAO,EAAC;MACP;IAAA,CACH,MAAI;MACDC,OAAO,CAACC,GAAG,CAAC,WAAW,CAAC;MACxB;MACA;MACA,MAAMC,cAAc,GAAG,CAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,CAAC;;MAEjC,IAAGR,KAAK,CAACS,kBAAkB,CAAC,CAAC,CAAC,EAAC;QAAC;;QAE5B;QACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,SAAS,CAACS,OAAO,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;UAC/C,IAAGR,SAAS,CAACS,OAAO,CAACD,CAAC,CAAC,CAACG,IAAI,CAACC,QAAQ,CAACd,KAAK,CAACS,kBAAkB,CAAC,CAAC,CAAC,CAAC,EAAC;YAC/D,IAAIP,SAAS,CAACS,OAAO,CAACD,CAAC,CAAC,CAACG,IAAI,CAACE,KAAK,CAAC,KAAK,CAAC,EAAE;cACxC,IAAGb,SAAS,CAACS,OAAO,CAACD,CAAC,CAAC,CAACG,IAAI,CAACG,UAAU,CAAChB,KAAK,CAACS,kBAAkB,CAAC,CAAC,CAAC,CAAC,EAAC;gBACjEP,SAAS,CAACS,OAAO,CAACD,CAAC,CAAC,CAACO,UAAU,GAAIT,cAAc,CAACR,KAAK,CAACS,kBAAkB,CAAC,CAAC,CAAC,CAAC;gBAC9ER,MAAM,CAACU,OAAO,CAACO,WAAW,CAAChB,SAAS,CAACS,OAAO,CAACD,CAAC,CAAC,EAAE,UAASS,GAAG,EAAE;kBAC3D;gBAAA,CACH,CAAC;cACN;YACJ;UACJ;;UAEA;UACA,IAAGnB,KAAK,CAACS,kBAAkB,CAAC,CAAC,CAAC,KAAK,OAAO,EAAC;YACvC,IAAGP,SAAS,CAACS,OAAO,CAACD,CAAC,CAAC,CAACG,IAAI,CAACG,UAAU,CAAC,CAAC,CAAC,EAAC;cACvC;;cAEAd,SAAS,CAACS,OAAO,CAACD,CAAC,CAAC,CAACO,UAAU,GAAIT,cAAc,CAACN,SAAS,CAACS,OAAO,CAACD,CAAC,CAAC,CAACG,IAAI,CAACO,MAAM,CAAClB,SAAS,CAACS,OAAO,CAACD,CAAC,CAAC,CAACG,IAAI,CAACD,MAAM,GAAG,CAAC,CAAC,CAAC;cACzHX,MAAM,CAACU,OAAO,CAACO,WAAW,CAAChB,SAAS,CAACS,OAAO,CAACD,CAAC,CAAC,EAAE,UAASS,GAAG,EAAE;gBAC3D;cAAA,CACH,CAAC;YACN;YACA;UACJ;QACJ;MAEJ,CAAC,MAAI;QACD;MAAA;IAER;EACF,CAAC,EAAE,CAACnB,KAAK,CAACS,kBAAkB,CAAE,CAAC;AAErC,CAAC;AAAAL,EAAA,CAhDYL,cAAc;EAAA,QAGPD,UAAU;AAAA;AAAAuB,EAAA,GAHjBtB,cAAc;AAAA,IAAAsB,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}