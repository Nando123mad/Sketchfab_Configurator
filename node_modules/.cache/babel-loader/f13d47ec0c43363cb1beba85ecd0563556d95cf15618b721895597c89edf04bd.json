{"ast":null,"code":"//Main\nimport{useRef,useEffect}from'react';//Additional Files\nimport{useIsMount}from'../useIsMount';import TextureInfo from'../../api/API_ModelInfo.json';//*********REFRENCE**************/\n//props.AccessorySelection[]\n//AccessorieID(int), ObjectID(int), TextureChange(bool), UID(int)\n//*********REFRENCE**************/\n//TODO This can be more dynamic, currently the textures are being \"imported\" every time. That run should be skipped if the texture has beeen imported in the past\n//Additionally, Diffuse, mettalic, roughness and normal assignment code is copy paste....theyre very similar and can be consolidated to smaller code otherwise it's a pain changing in 4 different places. \n//materials are reassigned to all objects at end during reset config. This can be more specific to only the materials that have been changed for less computation. \n//Adding texture change to accessories can add more complication in the future.....\nexport var TextureChange=function TextureChange(props,apiRef,materials){console.log(materials);//Function that runs and returns a bool on initial mount\nvar isMount=useIsMount();useEffect(function(){if(isMount){// console.log('mounting in textureChange')\n}else{if(props.AccessorySelection[2]){//confirms that it will be a texture change. (props.AccessorySelection[2] returns true or false)\nvar countGlock4=0;var DiffuseURL,MetallicURL,RoughnessURL,NormalURL;// console.log(materials)\n// //TODO: we should only add texture if it hasnt been added\n//Api fetch to retrieve URL information\nDiffuseURL=TextureInfo.Model[props.AccessorySelection[3]].Diffuse;MetallicURL=TextureInfo.Model[props.AccessorySelection[3]].Metallic;RoughnessURL=TextureInfo.Model[props.AccessorySelection[3]].Roughness;NormalURL=TextureInfo.Model[props.AccessorySelection[3]].Normal;console.log(DiffuseURL);console.log(MetallicURL);console.log(RoughnessURL);console.log(NormalURL);//DIFFUSE/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\napiRef.current.addTexture(DiffuseURL,function(err,textureId0){//Loop through all materials\nfor(var i=0;i<materials.current.length;i++){//Check that the material matches the accessory selection\nif(materials.current[i].name.endsWith(props.AccessorySelection[0])){// console.log(materials.current[i].name)//Specific material we are changing\nmaterials.current[i].channels.AlbedoPBR.texture={internalFormat:\"RGB\",magFilter:\"LINEAR\",minFilter:\"LINEAR_MIPMAP_LINEAR\",texCoordUnit:1,textureTarget:\"TEXTURE_2D\",uid:textureId0,wrapS:\"REPEAT\",wrapT:\"REPEAT\"};}else if(props.AccessorySelection[3]===1000000){//ResetConfig\n//Check that the material is not an accessoy\nif(!materials.current[i].name.includes(\"Accessory\")){materials.current[i].channels.AlbedoPBR.texture={internalFormat:\"RGB\",magFilter:\"LINEAR\",minFilter:\"LINEAR_MIPMAP_LINEAR\",texCoordUnit:1,textureTarget:\"TEXTURE_2D\",uid:textureId0,wrapS:\"REPEAT\",wrapT:\"REPEAT\"};}else{//the material belongs to an accessory\n}}}countGlock4++;//This is to check that it is the last texture being updated otherwise continue assigning the textures and the rest of the maps(Albedo, Mettalic, Roughness, Normal).\nif(countGlock4==4){//Loop through the material to update the specific material\nfor(var i=0;i<materials.current.length;i++){//This is where the material is set to the current model.. it's placed inside the texture function because otherwise it would be called too early. \nif(materials.current[i].name.endsWith(props.AccessorySelection[0])){apiRef.current.setMaterial(materials.current[i],function(err){console.log('Material Assigned');});}else if(props.AccessorySelection[3]===1000000){apiRef.current.setMaterial(materials.current[i],function(err){console.log('Material Assigned');});}}}});//METALLIC/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\napiRef.current.addTexture(MetallicURL,function(err,textureId1){for(var i=0;i<materials.current.length;i++){//Here is where we choose to assign for specific material\nif(materials.current[i].name.endsWith(props.AccessorySelection[0])){materials.current[i].channels.MetalnessPBR.texture={internalFormat:\"RGB\",magFilter:\"LINEAR\",minFilter:\"LINEAR_MIPMAP_LINEAR\",texCoordUnit:1,textureTarget:\"TEXTURE_2D\",uid:textureId1,wrapS:\"REPEAT\",wrapT:\"REPEAT\"};}else if(props.AccessorySelection[3]===1000000){//Check that the material is not an accessoy\nif(!materials.current[i].name.includes(\"Accessory\")){materials.current[i].channels.MetalnessPBR.texture={internalFormat:\"RGB\",magFilter:\"LINEAR\",minFilter:\"LINEAR_MIPMAP_LINEAR\",texCoordUnit:1,textureTarget:\"TEXTURE_2D\",uid:textureId1,wrapS:\"REPEAT\",wrapT:\"REPEAT\"};}else{//the material belongs to an accessory\n}}}countGlock4++;//This is to check that it is the last texture being updated otherwise continue the assigning the textures the rest of the maps(Albedo, Mettalic, Roughness, Normal).\nif(countGlock4==4){//Loop through the material to update the specific material\nfor(var i=0;i<materials.current.length;i++){//This is where the material is set to the current model.. it's placed inside the texture function because otherwise it would be called too early. \nif(materials.current[i].name.endsWith(props.AccessorySelection[0])){apiRef.current.setMaterial(materials.current[i],function(err){console.log('Material Assigned');});}else if(props.AccessorySelection[3]===1000000){apiRef.current.setMaterial(materials.current[i],function(err){console.log('Material Assigned');});}}}});//ROUGHNESS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\napiRef.current.addTexture(RoughnessURL,function(err,textureId2){//This is where the texture is assigned to the material the \"mat\" stands for material.\nfor(var i=0;i<materials.current.length;i++){//Here is where we choose to assign for specific material\nif(materials.current[i].name.endsWith(props.AccessorySelection[0])){materials.current[i].channels.RoughnessPBR.texture={internalFormat:\"RGB\",magFilter:\"LINEAR\",minFilter:\"LINEAR_MIPMAP_LINEAR\",texCoordUnit:1,textureTarget:\"TEXTURE_2D\",uid:textureId2,wrapS:\"REPEAT\",wrapT:\"REPEAT\"};}else if(props.AccessorySelection[3]===1000000){//Check that the material is not an accessoy\nif(!materials.current[i].name.includes(\"Accessory\")){materials.current[i].channels.RoughnessPBR.texture={internalFormat:\"RGB\",magFilter:\"LINEAR\",minFilter:\"LINEAR_MIPMAP_LINEAR\",texCoordUnit:1,textureTarget:\"TEXTURE_2D\",uid:textureId2,wrapS:\"REPEAT\",wrapT:\"REPEAT\"};}else{//the material belongs to an accessory\n}}}countGlock4++;//This is to check that it is the last texture being updated otherwise continue the assigning the textures the rest of the maps(Albedo, Mettalic, Roughness, Normal).\nif(countGlock4==4){//Loop through the material to update the specific material\nfor(var i=0;i<materials.current.length;i++){//This is where the material is set to the current model.. it's placed inside the texture function because otherwise it would be called too early. \nif(materials.current[i].name.endsWith(props.AccessorySelection[0])){apiRef.current.setMaterial(materials.current[i],function(err){console.log('Material Assigned');});}else if(props.AccessorySelection[3]===1000000){apiRef.current.setMaterial(materials.current[i],function(err){console.log('Material Assigned');});}}}});//NORMAL////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\napiRef.current.addTexture(NormalURL,function(err,textureId3){//This is where the texture is assigned to the material the \"mat\" stands for material.\nfor(var i=0;i<materials.current.length;i++){//Here is where we choose to assign for specific material\nif(materials.current[i].name.endsWith(props.AccessorySelection[0])){materials.current[i].channels.NormalMap.texture={internalFormat:\"RGB\",magFilter:\"LINEAR\",minFilter:\"LINEAR_MIPMAP_LINEAR\",texCoordUnit:1,textureTarget:\"TEXTURE_2D\",uid:textureId3,wrapS:\"REPEAT\",wrapT:\"REPEAT\"};}else if(props.AccessorySelection[3]===1000000){//Check that the material is not an accessoy\nif(!materials.current[i].name.includes(\"Accessory\")){materials.current[i].channels.NormalMap.texture={internalFormat:\"RGB\",magFilter:\"LINEAR\",minFilter:\"LINEAR_MIPMAP_LINEAR\",texCoordUnit:1,textureTarget:\"TEXTURE_2D\",uid:textureId3,wrapS:\"REPEAT\",wrapT:\"REPEAT\"};}else{//the material belongs to an accessory\n}}}countGlock4++;//This is to check that it is the last texture being updated otherwise continue the assigning the textures the rest of the maps(Albedo, Mettalic, Roughness, Normal).\nif(countGlock4==4){//Loop through the material to update the specific material\nfor(var i=0;i<materials.current.length;i++){//This is where the material is set to the current model.. it's placed inside the texture function because otherwise it would be called too early. \nif(materials.current[i].name.endsWith(props.AccessorySelection[0])){apiRef.current.setMaterial(materials.current[i],function(err){console.log('Material Assigned');});}else if(props.AccessorySelection[3]===1000000){apiRef.current.setMaterial(materials.current[i],function(err){console.log('Material Assigned');});}}}});}else{// console.log('Only model will be changed')\n}}},[props.AccessorySelection]);};","map":{"version":3,"names":["useRef","useEffect","useIsMount","TextureInfo","TextureChange","props","apiRef","materials","console","log","isMount","AccessorySelection","countGlock4","DiffuseURL","MetallicURL","RoughnessURL","NormalURL","Model","Diffuse","Metallic","Roughness","Normal","current","addTexture","err","textureId0","i","length","name","endsWith","channels","AlbedoPBR","texture","internalFormat","magFilter","minFilter","texCoordUnit","textureTarget","uid","wrapS","wrapT","includes","setMaterial","textureId1","MetalnessPBR","textureId2","RoughnessPBR","textureId3","NormalMap"],"sources":["/Users/nando/Documents/GitHub/Sketchfab_Configurator/src/Componets/3DComponents/TextureChange.jsx"],"sourcesContent":["//Main\nimport { useRef, useEffect } from 'react';\n\n//Additional Files\nimport { useIsMount } from '../useIsMount';\nimport TextureInfo from '../../api/API_ModelInfo.json'\n\n//*********REFRENCE**************/\n    //props.AccessorySelection[]\n    //AccessorieID(int), ObjectID(int), TextureChange(bool), UID(int)\n//*********REFRENCE**************/\n\n//TODO This can be more dynamic, currently the textures are being \"imported\" every time. That run should be skipped if the texture has beeen imported in the past\n//Additionally, Diffuse, mettalic, roughness and normal assignment code is copy paste....theyre very similar and can be consolidated to smaller code otherwise it's a pain changing in 4 different places. \n//materials are reassigned to all objects at end during reset config. This can be more specific to only the materials that have been changed for less computation. \n//Adding texture change to accessories can add more complication in the future.....\n\nexport const TextureChange = ( props, apiRef, materials ) => {\n    console.log(materials)\n    //Function that runs and returns a bool on initial mount\n    const isMount = useIsMount();\n    useEffect(() => {\n        if(isMount){\n            // console.log('mounting in textureChange')\n        }else{\n            if(props.AccessorySelection[2]){//confirms that it will be a texture change. (props.AccessorySelection[2] returns true or false)\n                var countGlock4 = 0;\n                var DiffuseURL, MetallicURL, RoughnessURL, NormalURL;\n                // console.log(materials)\n\n                // //TODO: we should only add texture if it hasnt been added\n                //Api fetch to retrieve URL information\n                DiffuseURL = TextureInfo.Model[props.AccessorySelection[3]].Diffuse;\n                MetallicURL = TextureInfo.Model[props.AccessorySelection[3]].Metallic;\n                RoughnessURL = TextureInfo.Model[props.AccessorySelection[3]].Roughness;\n                NormalURL = TextureInfo.Model[props.AccessorySelection[3]].Normal;\n                console.log(DiffuseURL)\n                console.log(MetallicURL)\n                console.log(RoughnessURL)\n                console.log(NormalURL)\n\n                //DIFFUSE/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                apiRef.current.addTexture(DiffuseURL, function(err, textureId0) {\n                    //Loop through all materials\n                    for (var i = 0; i < materials.current.length; i++) {\n                            //Check that the material matches the accessory selection\n                            if(materials.current[i].name.endsWith(props.AccessorySelection[0])){\n                                // console.log(materials.current[i].name)//Specific material we are changing\n                                materials.current[i].channels.AlbedoPBR.texture =  {\n                                    internalFormat: \"RGB\",\n                                    magFilter: \"LINEAR\",\n                                    minFilter: \"LINEAR_MIPMAP_LINEAR\",\n                                    texCoordUnit: 1,\n                                    textureTarget: \"TEXTURE_2D\",\n                                    uid: textureId0,\n                                    wrapS: \"REPEAT\",\n                                    wrapT: \"REPEAT\"\n                                };\n                            }else if(props.AccessorySelection[3] === 1000000){//ResetConfig\n                                //Check that the material is not an accessoy\n                                if(!materials.current[i].name.includes(\"Accessory\")){\n                                    materials.current[i].channels.AlbedoPBR.texture =  {\n                                        internalFormat: \"RGB\",\n                                        magFilter: \"LINEAR\",\n                                        minFilter: \"LINEAR_MIPMAP_LINEAR\",\n                                        texCoordUnit: 1,\n                                        textureTarget: \"TEXTURE_2D\",\n                                        uid: textureId0,\n                                        wrapS: \"REPEAT\",\n                                        wrapT: \"REPEAT\"\n                                    };\n                                }else{\n                                    //the material belongs to an accessory\n                                }\n                            }\n                    }\n                    countGlock4++; //This is to check that it is the last texture being updated otherwise continue assigning the textures and the rest of the maps(Albedo, Mettalic, Roughness, Normal).\n                    if (countGlock4 == 4){\n                    //Loop through the material to update the specific material\n                    for (var i = 0; i < materials.current.length; i++) {\n                        //This is where the material is set to the current model.. it's placed inside the texture function because otherwise it would be called too early. \n                        if(materials.current[i].name.endsWith(props.AccessorySelection[0])){\n                            apiRef.current.setMaterial(materials.current[i], function(err) {\n                                console.log('Material Assigned')\n                            });\n                        }else if(props.AccessorySelection[3] === 1000000){\n                            apiRef.current.setMaterial(materials.current[i], function(err) {\n                                console.log('Material Assigned')\n                            });\n                        }\n                    }\n                    }\n                });\n\n                //METALLIC/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                apiRef.current.addTexture(MetallicURL, function(err, textureId1) {\n                    for (var i = 0; i < materials.current.length; i++) {\n                        //Here is where we choose to assign for specific material\n                        if(materials.current[i].name.endsWith(props.AccessorySelection[0])){\n                            materials.current[i].channels.MetalnessPBR.texture = {\n                                internalFormat: \"RGB\",\n                                magFilter: \"LINEAR\",\n                                minFilter: \"LINEAR_MIPMAP_LINEAR\",\n                                texCoordUnit: 1,\n                                textureTarget: \"TEXTURE_2D\",\n                                uid: textureId1,\n                                wrapS: \"REPEAT\",\n                                wrapT: \"REPEAT\"\n                            };\n                        }else if(props.AccessorySelection[3] === 1000000){\n                            //Check that the material is not an accessoy\n                            if(!materials.current[i].name.includes(\"Accessory\")){\n                                materials.current[i].channels.MetalnessPBR.texture = {\n                                    internalFormat: \"RGB\",\n                                    magFilter: \"LINEAR\",\n                                    minFilter: \"LINEAR_MIPMAP_LINEAR\",\n                                    texCoordUnit: 1,\n                                    textureTarget: \"TEXTURE_2D\",\n                                    uid: textureId1,\n                                    wrapS: \"REPEAT\",\n                                    wrapT: \"REPEAT\"\n                                };\n                            }else{\n                                //the material belongs to an accessory\n                            }\n                        }\n                    }\n                    countGlock4++; //This is to check that it is the last texture being updated otherwise continue the assigning the textures the rest of the maps(Albedo, Mettalic, Roughness, Normal).\n                    if (countGlock4 == 4){\n                        //Loop through the material to update the specific material\n                        for (var i = 0; i < materials.current.length; i++) {\n                            //This is where the material is set to the current model.. it's placed inside the texture function because otherwise it would be called too early. \n\n                            if(materials.current[i].name.endsWith(props.AccessorySelection[0])){\n                                apiRef.current.setMaterial(materials.current[i], function(err) {\n                                    console.log('Material Assigned')\n                                });\n                            }else if(props.AccessorySelection[3] === 1000000){\n                                apiRef.current.setMaterial(materials.current[i], function(err) {\n                                    console.log('Material Assigned')\n                                });\n                            }\n                        }\n                    }\n                });\n\n                //ROUGHNESS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                apiRef.current.addTexture(RoughnessURL, function(err, textureId2) {\n                    //This is where the texture is assigned to the material the \"mat\" stands for material.\n                    for (var i = 0; i < materials.current.length; i++) {\n                        //Here is where we choose to assign for specific material\n                        if(materials.current[i].name.endsWith(props.AccessorySelection[0])){\n                            materials.current[i].channels.RoughnessPBR.texture =  {\n                                internalFormat: \"RGB\",\n                                magFilter: \"LINEAR\",\n                                minFilter: \"LINEAR_MIPMAP_LINEAR\",\n                                texCoordUnit: 1,\n                                textureTarget: \"TEXTURE_2D\",\n                                uid: textureId2,\n                                wrapS: \"REPEAT\",\n                                wrapT: \"REPEAT\"\n                            };\n                        }else if(props.AccessorySelection[3] === 1000000){\n                            //Check that the material is not an accessoy\n                            if(!materials.current[i].name.includes(\"Accessory\")){\n                                materials.current[i].channels.RoughnessPBR.texture =  {\n                                    internalFormat: \"RGB\",\n                                    magFilter: \"LINEAR\",\n                                    minFilter: \"LINEAR_MIPMAP_LINEAR\",\n                                    texCoordUnit: 1,\n                                    textureTarget: \"TEXTURE_2D\",\n                                    uid: textureId2,\n                                    wrapS: \"REPEAT\",\n                                    wrapT: \"REPEAT\"\n                                };\n                            }else{\n                                //the material belongs to an accessory\n                            }\n                        }\n                    }\n\n                    countGlock4++; //This is to check that it is the last texture being updated otherwise continue the assigning the textures the rest of the maps(Albedo, Mettalic, Roughness, Normal).\n                    if (countGlock4 == 4){\n                        //Loop through the material to update the specific material\n                        for (var i = 0; i < materials.current.length; i++) {\n                            //This is where the material is set to the current model.. it's placed inside the texture function because otherwise it would be called too early. \n                            if(materials.current[i].name.endsWith(props.AccessorySelection[0])){\n                                apiRef.current.setMaterial(materials.current[i], function(err) {\n                                    console.log('Material Assigned')\n                                });\n                            }else if(props.AccessorySelection[3] === 1000000){\n                                apiRef.current.setMaterial(materials.current[i], function(err) {\n                                    console.log('Material Assigned')\n                                });\n                            }\n                        }\n                    }\n                });\n\n                //NORMAL////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                apiRef.current.addTexture(NormalURL, function(err, textureId3) {\n                    //This is where the texture is assigned to the material the \"mat\" stands for material.\n                    for (var i = 0; i < materials.current.length; i++) {\n                        //Here is where we choose to assign for specific material\n                        if(materials.current[i].name.endsWith(props.AccessorySelection[0])){\n                            materials.current[i].channels.NormalMap.texture =  {\n                                internalFormat: \"RGB\",\n                                magFilter: \"LINEAR\",\n                                minFilter: \"LINEAR_MIPMAP_LINEAR\",\n                                texCoordUnit: 1,\n                                textureTarget: \"TEXTURE_2D\",\n                                uid: textureId3,\n                                wrapS: \"REPEAT\",\n                                wrapT: \"REPEAT\"\n                            };\n                        }else if(props.AccessorySelection[3] === 1000000){\n                            //Check that the material is not an accessoy\n                            if(!materials.current[i].name.includes(\"Accessory\")){\n                                materials.current[i].channels.NormalMap.texture =  {\n                                    internalFormat: \"RGB\",\n                                    magFilter: \"LINEAR\",\n                                    minFilter: \"LINEAR_MIPMAP_LINEAR\",\n                                    texCoordUnit: 1,\n                                    textureTarget: \"TEXTURE_2D\",\n                                    uid: textureId3,\n                                    wrapS: \"REPEAT\",\n                                    wrapT: \"REPEAT\"\n                                };\n                            }else{\n                                //the material belongs to an accessory\n                            }\n                        }\n                    }\n\n                    countGlock4++; //This is to check that it is the last texture being updated otherwise continue the assigning the textures the rest of the maps(Albedo, Mettalic, Roughness, Normal).\n                    if (countGlock4 == 4){\n                        //Loop through the material to update the specific material\n                        for (var i = 0; i < materials.current.length; i++) {\n                            //This is where the material is set to the current model.. it's placed inside the texture function because otherwise it would be called too early. \n                            if(materials.current[i].name.endsWith(props.AccessorySelection[0])){\n                                apiRef.current.setMaterial(materials.current[i], function(err) {\n                                    console.log('Material Assigned')\n                                });\n                            }else if(props.AccessorySelection[3] === 1000000){\n                                apiRef.current.setMaterial(materials.current[i], function(err) {\n                                    console.log('Material Assigned')\n                                });\n                            }\n                        }\n                    }\n                });\n            }else{\n                // console.log('Only model will be changed')\n            }\n        }\n      }, [props.AccessorySelection]);\n    \n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}